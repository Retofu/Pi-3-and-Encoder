# RS-485 Transmitter для Raspberry Pi 3

Этот скрипт предназначен для циклической передачи данных энкодера через интерфейс RS-485.

## Описание

Скрипт `rs.py` формирует и передает пакеты данных размером 120 байт через RS-485 с интервалом 3 мс. В пакете:
- Байт 0: 0x65 (заголовок)
- Байты 1-55 и 60-116: заполнены нулями
- Байты 56-59: угол в радианах (float32, little-endian)
- Байт 117: контрольная сумма CS = 0xFF - (0xFF & Σᵢ СДᵢ)
- Байт 118: 0x45 (заголовок)
- Байт 119: 0xCF (заголовок)

## Настройка

### 1. Настройка pigpio daemon
```bash
sudo systemctl enable pigpiod
sudo systemctl start pigpiod
```

### 2. Настройка RS-485

**Вариант A: Через последовательные порты (rs.py)**
Скрипт автоматически найдет доступные последовательные порты. Если RS-485 устройство не подключено, скрипт перейдет в режим симуляции.

**Вариант B: Через GPIO пины (rs_gpio.py) - для логического анализатора**
Используйте `rs_gpio.py` для прямой передачи через GPIO пины:

**Подключение к логическому анализатору:**
- GPIO14 (pin 8) - TX (передача данных)
- GPIO15 (pin 10) - RX (прием данных)  
- GPIO23 (pin 16) - DE/RE (управление направлением)

**Схема подключения:**
```
Raspberry Pi    Логический анализатор
GPIO14 (pin 8)  → Канал 1 (TX)
GPIO15 (pin 10) → Канал 2 (RX)
GPIO23 (pin 16) → Канал 3 (DE/RE)
GND            → GND
```

### 3. Настройка пинов энкодера
По умолчанию используются пины:
- GPIO17 (pin 11) - Фаза A
- GPIO22 (pin 12) - Фаза B  
- GPIO27 (pin 13) - Фаза Z

## Запуск

**Для работы с последовательными портами:**
```bash
python rs.py
```

**Для работы с GPIO пинами (логический анализатор):**
```bash
python rs_gpio.py
```

**Для тестирования RS-485 через GPIO:**
```bash
python test_rs485_gpio.py
```

## Структура пакета данных

```
Байт 0:       0x65                     (заголовок)
Байт 1-55:    [0x00, 0x00, ..., 0x00]  (55 байт)
Байт 56-59:   [угол в радианах как float32, little-endian]
Байт 60-116:  [0x00, 0x00, ..., 0x00]  (57 байт)
Байт 117:     [контрольная сумма CS]   (1 байт)
Байт 118:     0x45                     (заголовок)
Байт 119:     0xCF                     (заголовок)
```

## Параметры

- **Интервал передачи**: 3 мс
- **Размер пакета**: 120 байт
- **Скорость RS-485**: 9600 bps (по умолчанию)
- **PPR энкодера**: 1200 импульсов на оборот

## Остановка

Нажмите `Ctrl+C` для корректной остановки скрипта.

## Логирование

Скрипт выводит в консоль:
- Статус инициализации компонентов
- Список доступных последовательных портов
- Информацию о переданных пакетах (каждые 100 пакетов)
- Текущий угол в радианах и счетчик импульсов
- Hex-представление байтов 56-59 (угол)

## Решение проблем

### Ошибка "No such file or directory: '/dev/ttyUSB0'"
**Решение:** Скрипт теперь автоматически ищет доступные порты. Если RS-485 устройство не подключено, скрипт перейдет в режим симуляции.

### Проверка доступных портов
```bash
ls /dev/tty*
```

### Установка зависимостей
```bash
pip install pigpio pyserial
```

### Проверка работы pigpio
```bash
sudo systemctl status pigpiod
```

### Тестирование энкодера
Если энкодер не работает, используйте отдельный тест:
```bash
python test_encoder.py
```

### Диагностика проблем с энкодером
1. **Проверьте подключение пинов:**
   - A_PIN = GPIO17 (физический pin 11)
   - B_PIN = GPIO22 (физический pin 15) 
   - Z_PIN = GPIO27 (физический pin 13)

2. **Проверьте питание энкодера:**
   - VCC подключен к 3.3V или 5V
   - GND подключен к земле

3. **Проверьте состояние пинов:**
   - При запуске скрипт покажет текущее состояние пинов
   - Все пины должны показывать 0 или 1 (не -1)

4. **Проверьте pigpio daemon:**
   ```bash
   sudo systemctl start pigpiod
   sudo systemctl enable pigpiod
   ```
